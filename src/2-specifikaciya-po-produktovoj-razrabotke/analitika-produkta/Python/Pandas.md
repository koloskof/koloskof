# Pandas

Документация: [https://pandas.pydata.org/](https://pandas.pydata.org/docs/user_guide/index.html#user-guide)

На основе скринкаста: [https://www.youtube.com/watch?v=-sJxwvx0P20](https://www.youtube.com/watch?v=-sJxwvx0P20)

`df **=** pd**.**read_csv('https://raw.githubusercontent.com/jorisvandenbossche/pandas-tutorial/master/data/titanic.csv')`

## Cодержание

- **DataFrame**
- **Обращение к столбцу**
- **Слайсы, срезы структур данных, обращение к строкам**
- **Обращение по индексам в виде даты**
- **loc()** — локация
- **Арифметические вычисления**
- **Обращение к одному отдельному значению одного отдельного элемента**
- **iloc()** — вывод по индексам
- **Операторы сравнения** NaN (Not-A-Number)
- **copy()** — копирование массива
- **Добавление столбца**
- **Series**
- **at() —** присвоение нового значения конкретному элементу
- **iat()** — присвоение нового значения элементу по конкретному индексу
- **Pandas** + **NumPy**
- **Missing data** — работа с неровными данными
- r**eindex()** — реиндексирование
- **dropna()** — удалить NaN (все данные, которых нет)
- **fillna()** — заполнить все данные, которых нет
- **isnull()** — Результат null (ноль это или нет)
- **set_option()**, **describe()** — ...
- **mean()** — среднее значение
- **apply()** — функция в функции
- **concat(**) — функция конкатенации
- **append()** — добавить в конец
- **merge()** — соединение, как в базе данных
- **read_csv** — импорт сsv данных из источника
- **to_csv()** — запись файла
- **read_excel()** — импорт сsv данных из источника
- **groupby()**, **sum()**, **count()**
- **resample()**, **asfreq()** — разбиение по группировкам
- **Series со словарём**
- **get()** — возвращение значения
- **Создание серии из скaлярного значения** (одного числа)
- **Сложение серий** (арифметика с сериями)
- **Серия в качестве аргумента функции**
- **Сложение двух изменённых серий**
- **Использование арифметических выражений внутри функции**
- **Функция с параметром map()**
- **str.lower()** — работа со строками
- **Арифметика с датами**
- **Timedelta()** расчитывать сколько времени прошло или сколько его осталось
- **tail()** — вывод последних значений
- **Ключевые методы Data frames**

## Data frame

Основу **Pandas** составляют такие структуры данных, как Series и DataFrame.

**Series** — это одномерный массив, имеющий специальные метки (индексы) способные хранить данные любого типа.

**DataFrame** — это двумерный массив (матрица/таблица), имеющий специальные метки (индексы), который хранит в своих столбцах данные разных типов.

Для начала создадим **NumPy** масcив на 24 элемента и придадим ему форму в 6 строк и 4 колонки

```python
ave_data = np.array(np.arrange(24)).reshape((6, 4))
```

Создадим переменную **data** и воспользуемся функцией **Pandas** и мы попросим эту функцию начать с определенной даты. Для этого укажем два параметра: дату, а вторым аргументом укажем периоды и у нас их будет 6. Также давайте создадим переменную **ave_df**, в которые будем записывать значения созданные с помощью функции DataFrame. **DataFrame** — это такая табличная структура в Pandas. Она напоминает таблицы из Microsoft Excel и в чем-то она похожа на массив в NumPy, хотя и отдаленно. В эту функцию мы передаем наш массив **ave_data** и в качестве параметров мы хотим видеть даты и мы будем разделять колонки с помощью списка **1234**

```python
date = pd.date_range('20210101', periods=6) 
ave_df = pd.DataFrame(ave_data, index=dates, columns=list('1234'))
```

### Обращение к столбцам

Мы создали наш первый дата фрейм и давайте с помощью квадратных скобок выведем колонку номер 4 (Нужно обратить внимание, что когда мы обращаемся к столбцу, мы используем апостроф)

```python
ave_df['4']
```

Так же мы можем делать **слайсы**. Допустим укажем в квадратных скобках **1:3** и можем увидеть как выводятся соответствующие строки

```python
 ave_df[1:3]
```

Поскольку даты у нас выступают в роле индексов, мы можем указать соотвествующий отрезок даты начала и даты окончания в квадратных скобках и получим строки в этом промежутке

```python
ave_df['2021-01-01': '2021-01-05']
```

### loc

Так же для строк внутри нашего фрейма, можно использовать атрибут **loc**, от слова **location**. На него мы можем подать индекс нужной строки. Допустим мы хотим вывести две строчки и соответственно если мы обратимся к дата-фрейму с помощью аттрибута **loc** и подадим туда скажем интервал от одного до трех, то он выдаст нам вторую и третью строку

```python
ave_df.loc[dates[1:5]]
```

Так же можно использовать более замысловатые конструкции. Скажем, что мы хотим вывести все строчки в этом фрейме, но только первый и третий столбец. Для этого мы используем квадратные скобки, ставим двоеточие и внутри массива через запятую указываем соответствующие значения. Как мы можем видеть у нас отобразились все строки, но только два столбца

```python
avr_df.loc[:, ['1', '3']]
```

Мы можем комбинировать пройденные конструкции и вывести первый и третий столбец с первого по пятое января. Для этого вместо двоеточия выведем промежуток с датами

```python
ave_df.loc['2021-01-01': '2021-01-05', ['1', '3']]
```

Так же мы можем производить арифметические вычисления, прежде чем мы что-то выведем на экран. Давайте возьмем значение одного из элементов в нашей конструкции и умножим на 5

```python
ave_df.loc['2021-01-01': '2021-01-05', ['1', '3']][0] * 5
```

А теперь давайте посмотрим как можно обращаться к одному отдельному значению одного отдельного элемента. Для этого возьмем всю туже функцию **loc** и используем нашу переменную **dates** (в которой как мы помним хранятся наши индексы, которые являются датами) и обратимся и обратимся по индексу к первой строке

```python
ave_df.loc[dates[1], '1']
```

### iloc

Так же, для того чтобы обратиться к конкретной строке, мы можем использовать функцию **iloc** в которую нужно передать индекс строки

```python
ave_df.iloc[2]
```

Так же мы можем выбирать определенные строки и определенные столбцы. Для этого достаточно в качестве первого аргумента подать интервал соответствующий строкам, а в качестве второго интервал соответствующий столбцам

```python
ave_df.iloc[1:3, 2:5]
```

Или же просто перечислить строки и столбцы через запятую

```python
ave_df.iloc[[0, 1, 3], [0, 2]]
```

Так же мы можем ограничиться указывание одного параметра, а по второму сказать, что нам нужно всё, что имеется. В этом нам поможет двоеточие в качестве второго аргумента

```python
ave_df.iloc[1:3, :]
```

Так же мы можем ограничить второй параметр, а именно столбцы. И как мы отобразились все строки, а столбцы только те, что находятся в интервале индекса от **1** до **3**

```python
ave_df.iloc[:, 1:3]
```

### Операторы сравнения

Помимо этого мы можем использовать операторы сравнения: больше или равно / меньше или равно. Например, в качестве аргумента мы подаём наш дата-фрейм и говорим чтобы нам отобразились все элементы, которые больше или равно пяти. В таком случае те элементы, которые меньше возвращаются как NaN (иными словами это некоторое не участвует в выдачи)

```python
ave_df[ave_df >=5]
```

Создаем новый дата-фрейм у которого будет **10 строк** и **4 столбца**. Индексами строк будет служить диапазон дат, а названиями столбцов A B C D

```python
start_date = '20210101'
ave_numpy_data = pd.array(np.arange(40).reshape(10, 4))
dates = pd.date_range(start_date, periods = 10)
ave_df = pd.DataFrame(ave_numpy_data, index=dates, columns=list('ABCD'))
```

### copy

Давайте создадим новый массив **ave_df_cars** и скопируем в него все содержимое **ave_df**, используя метод **copy**

```python
ave_df_card = ave_df.copy()
```

### Добавление столбца

Добавим еще один столбец, в котором в качестве значений лежат названия авто

```python
ave_df_cars['Cars'] = ['Ford', 'Opel', 'Mazda', 'Mitsubishi', 'Renault', 'Lada', 'Hammer', 'BMW', 'Mercedes', 'VW' ]
```

А теперь обратимся к нашим строчным индексам через функцию **date_range** в которую в качестве аргументов передаем переменную **start_date** с периодом 10

```python
pd.date_range(start_date, period=10)
```

## Series

Дальше мы будем рассматривать работу с так называемыми **Series**. Это очень важная структура данных, которая используется с последовательностью одномерных данных. По сути дела это просто массив, только с некоторыми расширенными возможностям.

Для этого мы используем функцию Series в которую передам массив от 1-го до 10-ти и в качестве индекса передаем функцию **date_range** в которую так же передаем переменную **start_date** и **10 периодов**. И мы можем увидеть что у нас получилась структура данных, где каждому числу соответствует своя дата

```python
pd.Series([1,2,3,4,5,6,7,8,9,10], index=date_range(start_date, period=10))
```

Мы также можем добавить дополнительную колонку. Для этого объявляем переменную **ave_series** и скопируем всё наше предыдущее выражение с единственной разницей, что мы добавим колонку Extra, которая будет состоять из значений, которые у нас уже имеются, только умноженных на 10 и добавим ещё двойку в конце (такие конструкции удобны, если нам например нужно рассчитывать налог или ещё что-то в этом роде)

```python
ave_series = pd.Series([1,2,3,4,5,6,7,8,9,10], index=date_range(start_date, period=10))
ave_df['Extra'] = ave_series * 10 + 2
ave_df
```

Теперь вернемся к нашему уже созданному дата фрейму с машинами и добавим туда эту колонку extra

```python
ave_df_cars['Extra'] = ave_series * 10 + 2
```

### at

С помощью следующей конструкции, мы можем присвоить новое значение конкретному элементу

```python
ave_df_cars.at[date[4], 'Cars'] = 'Citroen'
```

### iat

Давайте еще посмотрим один индекс оператор доступный в Pandas, который называется **iat** и указываем третий индекс строки и второй индекс столбца, а дальше просто меняем значение этого элемента на **666**

```python
ave_df_cars.iat[3, 2] = 666
```

### Pandas + NumPy

Преимущество Pandas заключается в том, что внутри мы можем работать с NumPy. И комбинировать конструкции между собой так как они отлично работают вместе. Например, мы можем создать массив **ave_new_array**, который будет длинной ave_df_cars, в каждый элемент можем умножить на **10** и прибавить **5**. Соответственно эта комбинация функций оценит длину массива **ave_df_cars** и произведет арифметические вычисление на каждом из элементов

```python
ave_new_array = np.array(np.arange(len(ave_df_cars))) * 10 + 5
```

Причем мы можем взять получившийся массив **ave_new_array** и добавить его в качестве получившейся колонки в **ave_df_cars**. Для этого дадим имя колонки E и присвоим ей **ave_new_array**

```python
ave_df_cars['E'] = ave_new_array
```

## Missing Data

Ни для кого не секрет, что данные в реальном мире не всегда оказываются полными как те, что в синтетических примерах. Поэтому нам необходимо научиться работать с данными, когда часть элементов отсутствует или не соответствует каким-то нашим требованиям.

В качестве примера давайте создадим массив **laptops**, в котором перечислим через запятую марки известных производителей. Это массив нам понадобиться для будущих манипуляций

```python
laptops = ['Lenovo', 'Dell', 'HP', 'Chrome', 'Macbook']

```

А сейчас создадим дата-фрейм. Для этого воспользуемся функцией **DataFrame** и внутри нее указываем, что мы хотим колонки из **5 наименований**. Пусть первая колонка будет price c ценами, а вторая колонка **disk_space** будет представлена в виде места на диске. И давайте укажем в качестве индекса наш ранее созданный массив laptops

```python
laptops_df = pd.DataFrame({
	'price': [350, 400, 500, 560, 1000],
	'disk_space': [0.5, 1, 2, 3, 1.5]},
	index= laptops)

laptops_df
```

### reindex

По каким-то неопределенным причинам мы решили создать второй массив **more_laptops**. Скопируем в него все наименования их массива laptops , но поменяем **Сhromebook** на **Huawei**. И создадим под это дело новый фрейм, который назовем **laptop_df_2**, но на этот раз вместо того, чтобы использовать функцию **DataFram**e, мы скопируем предыдущий фрейм **laptops_df** и просто и просто переиндексируем с помощью функции **reindex**, передадим в него массив **more_laptops**. В результате нас будет ждать новый массив, в котором все индексы заменены с laptops на **more_laptops**. В результате мы можем увидеть, что индекс **Huawei** появился, а значений цены и **disc_space** для него нет, поэтому Pandas возвращает **NaN** для этих значений

```python
more_laptops = ['Lenovo', 'Dell', 'HP', 'Huawei', 'Macbook']
laptops_df_2 = laptops_df.reindex(more_laptops)
laptops_df_2
```

### dropna

Двигаемся дальше и создадим новый фрейм **laptops_df_3**, который будет ровняться **laptops_df_2**, но для него мы будем использовать функцию **dropna**, которы удалит все данные **Not a Number** и в скобках допишем способ **how=any** (то есть любые). И по результату мы увидим, что у нас пропал наш Huawei

```python
laptops_df_3 = laptop_df_2.dropna(how='any')
```

### fillna

Но, чтобы не решать задачу таким радикальным способом, мы можем воспользоваться функцией **fillna** и указать **value** равным **100** и тогда во все значения **NaN** заменятся на **100**. В результате у нас получилась и price равный **100** и **space** равный **100**

```python
laptops_df_3 = laptop_df_2.fillna(value=100)
```

### isnull

В Pandas так же присутствует функция **isnull**, которая является булевой функцией, котора вернёт либо **true** / либо **false**. И с помощью нее мы можем проверить отсутствующие значения в нашем фрейме **laptop_df_2** и как мы видим вместо **NaN**, у **Huawei** вернулось True (то есть другими словами они отсутствуют)

```python
pd.isnull(laptops_df_2)
```

Так же мы можем делать любые манипуляции дата-фрейме. Вся простейшая арифметика полностью доступна в **Pandas**. Например, умножить все значения элементов на 10

```python
laptops_df_2 * 10
```

## Stats

Так же мы можем указывать какими мы хотим видеть элементы при помощи встроенных функций. Например, **set_options** и в качестве параметра данной функции мы подаём **precision**. То есть количество знаков после запятой. В данном случае это 2. И давайте теперь выведем наш **laptops_df_2** используя статистическую функцию **describe**, которая должна вывести для нас значения: средней величины, стандартного отклонения, минимальной величины, все персентиль для всех значений в колонке **price** и **disc_space**. Это крайне полезная функция, с документацией которой следует ознакомиться более подробно в документации [ссылка]

```python
pd.set_option('display.percision', 2)
laptops_df_2.describe()
```

### Mean

Мы так же можем вывести среднее значение используя функцию mean

```python
laptops_df_2.mean()
```

А если мы передадим в функцию mean единицу, то мы получим уже значения построчно и выведем значения каждого элемента колонки price по всем индексам

```python
laptops_df_2.mean(1)
```

### apply

Есть ещё одна интересная функция Apply, она принимает в себя некоторую функцию, которую мы подаём в качестве аргумента. К примеру если передадим аккумулятивную функцию **NumPy**, то это выразится в том, что все значения будут собранны в одну сумму, если же у нас значения строчные то произойдет конкатенация значений вниз по цепочке

```python
laptops_df_2.apply(np.cumsum, axis=0)
```

### cancat

Вообще функция конкатенации встречается во всех языках и фремворках, так как при работе с данными она особенно полезна. Для этого мы объявим переменную **pieces**, которая будет представлять собой список из трех элементов. Каждый который, является частью нашего фрейма

```python
peices = [laptops_df_2[:1], laptops_df_2[1:3], laptops_df_2[3:]]
```

Идея здесь будет состоять в том, что мы используя функцию concat мы объединим эти три раздельные части в единое целое. Для этого мы объявим новую переменную **new_list** и теперь обращаясь к определенному элементу списка **pieces** по индексу, мы можем начать их соединять. Но никто не сказал, что мы можем это делать в нужном порядке. Например, в данном случае мы соединим первую часть и последнюю часть, минуя второй элемент. То есть функция склеит эти два разрозненных куска в единое целое

```python
new_list = pieces[0], pieces[2]
pd.concat(new_list)
```

Теперь объявляем новую переменную **new_last_row**, которая будет ровна элементу по индексу **2**, а по индексу **2** у нас находится **HP**

```python
new_last_row = laptops_df_2.iloc[2]
```

### Append

При помощи функции **append**, мы можем добавить его в конец нашего фрейма **laptops_df_2**, как мы видим **HP** у нас теперь есть и в середине и в самом конце

```python
laptops_df_2.append(new_last_row)
```

### Merge

И следующая важная функция для рассмотрения — это функция merge или слияние. Merge по сути дела обеспечивает объединение неких объектов по столбцам или индексам. Например, у нас есть два фрейма **left** и **right**

```python
left = pd.DataFrame('my_key': ['K0', 'K1', 'K2', 'K3'],
										'A': ['A0', 'A1', 'A2', 'A3'],
										'B': ['B0', 'B1', 'B2', 'B3'])
)
left = pd.DataFrame('my_key': ['K0', 'K1', 'K2', 'K3'],
										'C': ['C0', 'C1', 'C2', 'C3'],
										'D': ['D0', 'D1', 'D2', 'D3'])
)]
```

Мы можем объявить переменную **result** и при помощи функции merge, подавая в нее в качестве аргументов **left**, **right** и то какой у нас будет внешний ключ, например **my_key**, мы можем получить сводную таблицу **result**

```python
result = pd.merge(left, right, on='my_key')
result
```

## Import data

А теперь пришло время импортировать данные из открытых источников. Рассмотрим два самых популярных сервиса: Kaggle ([https://www.kaggle.com/](https://www.kaggle.com/)) и UCI ([https://archive.ics.uci.edu/ml/index.php](https://archive.ics.uci.edu/ml/index.php))

### Read CSV

Создаем переменную **bank_d**f и при помощи функции **read_csv**, мы будем считывать **CSV** (comma separated values) файл. И давайте выведем на экран первые **100** записей. Этот файл является сборником данных по неким банковским служащим

```python
bank_df = pd.read_csv('https://raw.githubusercontent.com/AveCoders/Pandas/main/bank.csv')
print(bank_df.head(100))
```

На самом деле при помощи Pandas мы можем как считывать **CSV** файлы, так и записывать их. И, в том числе мы можем использовать не только формат **CSV**, но ещё и множество других форматов

### To CSV

Давайте теперь попробуем записать наш **CSV** файл. Для этого есть отличная команда **to_csv** в которую мы передаем путь с названием фала и расширением **.csv** Таким образом мы достаточно просто сохранили новый файл

```python
bank_df.to_csv('/Users/meeq/Desktop.bank_update.csv')
```

### read_excel

А теперь давайте скопируем другой файл. Он называется **Online Retai**l. И он уже в формате **Excel-таблицы** (.xlsx). Создаем новую переменную и указываем путь к файлу **Online Retail.xlsx**. Затем нам нужно его считать и для этого объявляем новую переменную online_retail_df и про помощи Pandas-функции **read_excel** мы его будем считывать. Для этого передаем в функцию нашу переменную **retail_file**, и в качестве второго параметра указываем имя или номер таба с которого мы будем считывать данные, третим параметром мы укажем, что мы не хотим указывать строчную маркеровку, а последним параметром мы указываем как обращаться с отсутствующими данными, то есть с **NaN** и мы заменим их на **NA**. На этом подготовительные завершены и теперь давайте выведем на экран наш **online_retail_df** и посмотрим, что там внутри

```python
retail_file = "https://github.com/AveCoders/Pandas/blob/main/Online%20Retail.xlsx"
online_retail_df = pd.read_exel(retail_file, 'Online Retail', index_col=None, na_values=['NA'])

```

### groupby

В результате у нас отобразился какой-то инвентарный список, с которым мы будем работать. Опять же Pandas позволят использовать подобие SQL-функции **groupby** и мы можем сгруппировать элементы по определенному параметру например по количеству **Quantity**. В выдаче мы также можем увидеть сколько строк и колонок участвовало в операции

```python
online_retail_df.groupby('Quantity').sum()
```

А теперь давайте сделаем группировку по стране **Country** и на этот раз мы будем считать, а не суммировать. То есть по сути это подсчет значений внутри какой-то группы. Вот мы увидели что нам, выдали список всех из стран, которые у нас есть в инвентаре (видимо что-то заказывали) и по каждый мы видим подсчитанную номенклатуру

[ вставить пример ]

## Resampling

Двигаемся дальше и теперь поговорим про Ресемплирование и давайте объявим новую переменную **ave_index**. Она у нас будет равне некоторому временному интервалу. Перым параметром мы указываем 1 января 2021 года, вторым количество периодов (например 10) и последний параметр этот частота (то есть минуты). И теперь если мы введем содержимое на экран, то мы увидим что периоды идут поминутно

```python
ave_index = pd.date_range('1/1/20201', periods=10,freq='min')
ave_index
```

И мы так же можем создавать pandas-серию при помощи этого. Объявим переменную **ave_series**. В качестве первого параметра мы передаём numpy-функцию на создание массива из 10 элементов, и в качестве другого параметра мы переём индекс и для индекса мы используем нашу переменную **ave_index**. Давайте выведем все на экран и увидим, что у нас есть временная серия из 10 элементов от 0 до 9 и для каждой из них индексом является дата

```python
ave_series = pd.Series(np.arrange(10), index=ave_index)
ave_series
```

### Resample

И теперь давайте используем функцию **resample**. С помощью неё мы разобьем нашу серию по 5 минутам. И просуммируем все то, что попадает в эти пятиминутные интервалы. По результату вычисления у нас получилось два интервала. Сумма значений элементов первого интервала получилась **10**, а второго **5**

```python
ave_series.resmple('5min').sum()
```

Нужно доработать секцию и расширить количество примеров

### Series со словарём

Series еще интересен тем, что мы можем использовать структуру данных словарь, которая включает в себя пары ключ : значение. И в качестве примера создадим переменную **ave_dictionary** с несколькими примерами ключей и значений. Дальше создадим нашу серию **ave_another_series**, которая в качестве аргумента будет принимать наш словарь. Давайте все выведем на экран и обратив внимание как всё это выглядит. В данном случае ключ становится подобием индекса

```python
ave_disctionary = { 'A' : 30, 'B' : -5.8, 'C' : 666 }
ave_another_series = pd.Series(ave_disctionary)
ave_another_series
```

И мы так же можем обращаться к определенному значению по его ключу

```python
ave_another_series['B']
```

Если же мы решим добавить индексы самостоятельно. Например, мы воспользуемся всем тем же словарем и подадим его в качестве параметра в функции Serries, а в качестве второго параметра у нас будет с некоторым набором ключей. Выведем на экран и увидим, что те ключи, которые не обладали значениями и будут выведены как **NaN**

```python
pd.Serries(ave_disctionary, index=['D', 'C', 'B', 'E'])
```

### get

Мы так же можем возвращать значения при помощи функции **get**, передавая в качестве параметра ключ

```python
ave_another_series.get('A')
```

### Cоздание серии из скaлярного значения (одного числа)

Можно так же присвоить всем индекса какое-то одно значение. Пусть это будет 5

```python
pd.Series(5., index=['A', 'B', 'C', 'D', 'E'])
```

### Сложение серий, арифметика с сериями

Мы так же вольны использовать простое арифметическое сложение. Для примера давайте возьмем серию **ave_simple_series** и сложим её с собой же, но если мы выведем на экран оригинальную серию, мы увидим, что она не была изменена

```python
ave_simple_series + ave_simple_series
ave_simple_series
```

Так же мы можем прибавлять какое-то скалярное значение. Например, **1000** и мы увидим, что каждое значение элемента увеличится на эту единицу. При том, что оригинальная серия будет оставаться прежней

```python
ave_simple_series + 1000
```

Так же мы можем умножить значение каждого элемента на **5**

```python
ave_simple_series * 5
```

### серия в качестве аргумента функции

Так же мы можем передавать в нашу серию в Numpy-функции. Например, в функцию экспоненты

```python
np.exp(ave_simple_series)
```

Если мы захотим вывести элементы серии начиная с какого-то определенного индекса, то мы можем воспользоваться следующей конструкцией

```python
ave_simple_series[1:]
```

Аналогично мы можем сделать выборку и отсечь последний элемент

```python
ave_simple_series[:-1]
```

Мы заметим, что при работе со словарями в любой выдаче, у нас всегда присутствует индекс, в отличие от работы с теми же массивами

### Сложение двух изменённых серий

Если же мы сложим две измененные серии. Ту, где мы просил выдать от первого элемента и ту, где мы отсекали последний элемент, то мы увидим, что суммирование произошло только с теми элементами, которые присутствовали в обеих сериях. Несмотря на то, что в последней серии где мы отсекали последний элемент, присутствовал элемент по индексу 0, он все равно возвращается как **NaN,** потому что такой элемент отсутствовал в нашей первой выборке

```python
ave_simple_series[1:] + ave_simple_series[:-1]
```

### функция с параметром серии map()

Для следующего фокуса нам придется создать функцию **mult_by_ten**, которая будет принимать на вход нашу серию и возвращать каждый элемент этой серии умноженный на 10

```python
def mult_by_ten(input_element):
	return input_element * 10.0
```

Одна иллюстрация того, как мы можем изменять элементы в серию. Например при помощи функции map, определенной значение будет поступать на вход этой функции. Это значение будет умножено на **10**, а затем оно будет отослано в оригинальную серию под оригинальный ключ, но уже умножено на **10**

```python
ave_simple_series.map(mult_by_ten)
```

Далее представим, что мы создали функцию из следующих элементов. И давайте посмотрим, что у нас получилось

```python
series_of_random_stuff = pd.Series([ 'A', 'B', 'C', 'Abracadabra', 'Boba', np.nan , 'DOG', 'Cow', 'Helicopter'])
series_of_random_stuff
```

## str.lower

И функция, о которой стоит упомянуть — это функция для работы со строчными значениями. А точнее их реестром. Например, мы можем их сделать все строчными. Для этого мы можем использовать функцию **lower** и вернуть все значения, но буквы в них будут строчными

```python
series_of_random_stuff.str.lower()
```

## Арифметика с датами

И ещё одно не маловажное преимущество работы Pandas — это арифметическая работа с датами. Для этого нам нужно импортировать **datetime**

```python
from datetime import datetime
```

### now

И теперь давайте попробуем как это работает, для начала выведем текущую дату

```python
now = datetime.now()
now
```

А сейчас мы можем начать работу с нашим объектом при помощи различных функций в частности обращаясь через now к году, месяцу и дню мы можем получить у же нормальную читаемую дату

```python
now.year, now.month, now.day
```

Мы так же можем рассчитывать какое время прошло с какого-либо момента, сколько его осталось до какого-либо момента. Например, при помощи арифметической функции. Давайте создадим функцию **delta** и не присвоим результат вычитания текущей даты минус даты в которую планировался конец света (1 января 2012 года) и мы увидим сколько дней прошло с тех пор XXXX дней XXXX секунд XXXX микросекунд

```python
delta = now - datetime(2012, 1, 1)
delta
```

### Timedelta

Опять же чтобы не тащить весь этот прицеп за собой, мы можем использовать функцию day и это вернет нам количество прошедших дней

```python
delta.days
```

Мы также можем использовать функцию **timedelta** и с её помощью мы можем парсить string, переводить его в дату. Давайте воспользуемся этой функцией **Timedelta** и в качестве аргумента мы напишем **5 days 10 hours** и на выходе мы получим уже числовое значение

```python
pd.Timedelta('5 days 10 hours')
```

Но и это ещё не все. Допустим формат записи, когда мы подаем в **Timedelta** некий ключ и приравниваем его к какому-либо значению. Например, мы можем записать day равное двум и seconds равное десяти. На выходе мы получим **2 дня** и **10 секунд**

```python
pd.Timedelta(days=2, seconda=10)
```

И как вы можете догадаться, мы можем смешивать строковое и числовое значение. Например, в параметрах мы пишем 1, а в качестве юнита указываем d, то есть день. По результату выполнения функция нам вернулся **1 день** и **00:00:00** оставшегося времени

```python
pd.Timedelta(1, unit='d')
```

### datetime

Теперь перейдем к чему-то более осознанному. В следующем примере мы объявим ряд переменных: первым числом будет Новый год, вторым День абсурда, а третьем день независимости республики Тувалу

```python
new_year = datetime(2021, 1, 1)
print(new_year)

national_absurdity_day = datetime(2021, 11, 20)
print(national_absurdity_day)

Tuvalu_independence_day = datetime(2021, 10, 1)
print(Tuvalu_independence_day)
```

Давайте предположим, что мы знаем, что может отдохнуть между днем абсурда и днем независимости Тувалу. Чтобы вычислить это промежуток времени мы просто отнимаем одно от другого и результат запишем в переменную **time_to_relax**. По результату мы видим, что наш отпуск будет составлять **50 дней**

```python
time_to_relax = national_absurdity_day - Tuvalu_independence_day
time_to_relax
```

### date_range

А теперь мы воспользуемся Pandas-функцией **date_range** для создания кастомного промежутка времени. В качестве параметров мы подаем дату международного дня абсурда (дни), в качестве периода мы будем подавать значение нашей переменной **time_to_relax** в днях и последний параметр это частота

```python
time_to_relax_range = pd.date_range(national_absurdity_day, period=time_to_relax.days, freq='D')
```

### tail

А теперь мы воспользуемся этой конструкцией для создания ещё более сложной конструкции. Для этого создаем переменную **time_to_relax_series**. Далее мы используем panda-серию и в качестве параметра мы передаем сначала генератор псевдослучайных чисел, к которой в качестве аргумента даем переменную **time_to_relax.days** (с количеством дней) и далее второй параметр это у нас индекс, который равен **time_to_relax_range**. И после выведем на экран 5 последних значений этой серии. Мы видим, что псевдослучайные числа была расфасованы по всей серии в качестве значений

```python
time_to_relax_series = pd.Series(np.random.randn(time_to_relax.days), index=time_to_relax_range)
time_to_relax_series.tail()
```

Давайте снова вернемся к дата-фреймам и рассмотрим несколько ключевых методов. Мы создали словарь **ave_dictionary** с ключами **A**, **B**, **C** и числовыми значениями, а далее мы выводим отдельно ключи словаря и отдельно значения словаря и получаем ожидаемый результат

```python
ave_dictionary = {'A': 20, 'B': -20, 'C': 666}
print(ave_dictionary.keys())
print(ave_dictionary.values())
```

Теперь создадим дата-фрейм при помощи соответствующего метода. Назовём нашу переменную **ave_dictionary_df** и в качестве аргументов в нашу переменную мы подаем словарь **ave_dictionary**, в качестве индексов мы будем использовать всего два: **start** и **finish**. и мы увидим, что ключи будут выступать в качестве индексов, в значения будут равномерно распределены (или реплицированы), чтобы заполнить пустоту. По сути дела значения обеих строк это дубликаты. Просто под разными индексами

```python
ave_dictionary_df = pd.DataFrame(ave_dictionary, index=['start', 'finish'])
ave_dictionary_df
```

## Ключевые методы D**ata Frames**

В первом примере у нас словарь с одним ключом и несколькими значениями, которые будут распределены по колонкам

```python
book_df_pd.DataFrame({ 'AAA' : [4, 5, 6, 7], 'CCC' : [100, 50, -30, -50] })
book_df
```

Во втором примере у нас словарь у которого есть два ключа **one** и **two**, а его значения по сути являются сериями и у нас так же присутствуют индексы. Недостающее значение возвращено как NaN

```python
series_dictionary = { 'one' : pd.Series([1., 2., 3.], index=['a', 'b', 'c']),
											'two' : pd.Series([1., 2., 3., 4.]), index=['a', 'b', 'c', 'd'])}

series_df = pd.DataFrame(series_dictionary)
series_df
```

Третий пример это словарь состоящий из списков, каждый элемент которого является строкой

```python

fresh_staf = {'vegetables': ['onion', 'courgette', 'aubergine', 'pepper'],
							'fruit' : ['apple', 'pear', 'persimon', 'plum']}

pd.DataFrame(fresh_staf)
```

В четвертом примере у нас вместо словаря содержащего списки, выведен список содержащий словари. Как мы видим pandas прекрасно справился с этим и сформировал на их него дата-фрейм

```python
some.data = [{'a' : 1, 'b' : 2}, {'a': 5, 'b' : 10, 'c': 20}]
pd.DataFrame(some_data)
```